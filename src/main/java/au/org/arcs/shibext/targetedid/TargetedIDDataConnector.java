/**
 * 
 */
package au.org.arcs.shibext.targetedid;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.digest.DigestUtils;

import net.shibboleth.idp.attribute.resolver.AbstractDataConnector;
import net.shibboleth.idp.attribute.resolver.ResolvedAttributeDefinition;
import net.shibboleth.idp.attribute.resolver.context.AttributeResolutionContext;
import net.shibboleth.idp.attribute.resolver.context.AttributeResolverWorkContext;
import net.shibboleth.idp.attribute.resolver.ResolutionException;
import net.shibboleth.idp.attribute.IdPAttribute;
import net.shibboleth.idp.attribute.IdPAttributeValue;
import net.shibboleth.idp.attribute.StringAttributeValue;
import net.shibboleth.utilities.java.support.collection.LazyMap;
import net.shibboleth.utilities.java.support.component.ComponentInitializationException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import au.org.arcs.shibext.sharedtoken.MiscHelper;

/**
 * @author Damien Chen
 * 
 */
public class TargetedIDDataConnector extends AbstractDataConnector {

	/** Class logger. */
	private final Logger log = LoggerFactory
			.getLogger(TargetedIDDataConnector.class);

	/** Minimum salt length */
	public static final int MINIMUM_SALT_LENGTH = 16;
	/** ID of the attribute generated by this data connector. */
	private String generatedAttributeId;

	/**
	 * ID of the attribute whose first value is used when generating the
	 * computed ID.
	 */
	private String sourceAttributeId;

	/** Salt used when computing the ID. */
	private byte[] salt;

	private static String SEPARATOR = ",";

	public TargetedIDDataConnector() {
		super();
		log.debug("construct empty TargetedIDDataConnector ...");
	}

	/**
	 * Constructor.
	 * 
	 * @param generatedAttributeId
	 *            ID of the attribute generated by this data connector
	 * @param sourceAttributeId
	 *            ID of the attribute whose first value is used when generating
	 *            the computed ID
	 * @param idSalt
	 *            salt used when computing the ID
	 */
	public TargetedIDDataConnector(String generatedAttributeId,
			String sourceAttributeId, byte[] idSalt) {

		try {
			log.debug("construct TargetedIDDataConnector ...");
			setGeneratedAttributeId(generatedAttributeId);
			setSourceAttributeId(sourceAttributeId);
			setSalt(idSalt);
		} catch (Exception e) {
			// catch any exception to let IdP go on
			log.error("Failed to construct TargetedIDDataConnector", e);
		}
	}
	
	/** Initialize the connector - check all required properties have been set
	 * @see net.shibboleth.idp.attribute.resolver.AbstractDataConnector#doInitialize()
	 */
	@Override
	protected void doInitialize() throws ComponentInitializationException {
		super.doInitialize();
		
		if (MiscHelper.isEmpty(sourceAttributeId)) 
			throw new ComponentInitializationException(
					"Source attribute ID must be set and not empty");
		
		if (MiscHelper.isEmpty(generatedAttributeId)) 
			throw new ComponentInitializationException(
					"Generated attribute ID must be set and not empty");

		if (salt == null || salt.length < MINIMUM_SALT_LENGTH)
			throw new ComponentInitializationException(
					"Salt must be set and at least "+MINIMUM_SALT_LENGTH+" bytes in size.");
	}

	/** {@inheritDoc} */

	@Override
	protected Map<String, IdPAttribute> doDataConnectorResolve(
			AttributeResolutionContext resolutionContext, AttributeResolverWorkContext resolverWorkContext)
			throws ResolutionException {
		
		log.debug("starting TargetedIDDataConnector.resolve( ) ...");

		Map<String, IdPAttribute> attributes = new LazyMap<String, IdPAttribute>();

		try {
			String targetedID = getTargetedID(resolutionContext, resolverWorkContext);
			IdPAttribute attribute = new IdPAttribute(getGeneratedAttributeId());
			Collection<IdPAttributeValue<String>> values = new ArrayList<IdPAttributeValue<String>>();
			values.add(new StringAttributeValue(targetedID));
			attribute.setValues(values);			
			attributes.put(attribute.getId(), attribute);
			log.info("successfully generated " + generatedAttributeId + " : " + targetedID);
		} catch (Exception e) {
			// catch any exception to let IdP go on
			log.error("Failed to resolve " + generatedAttributeId, e);
		}
		return attributes;
	}

	/**
	 * Gets the persistent ID stored in the database. If one does not exist it
	 * is created.
	 * 
	 * @param resolutionContext
	 *            current resolution context
	 * 
	 * @return persistent ID
	 * 
	 * @throws ResolutionException
	 *             thrown if there is a problem retrieving or storing the
	 *             persistent ID
	 */
	private String getTargetedID(AttributeResolutionContext resolutionContext, AttributeResolverWorkContext resolverWorkContext)
			throws ResolutionException {

		String localId = getLocalId(resolutionContext, resolverWorkContext);
		String targetedID = createTargetedID(resolutionContext, localId, salt);
		return targetedID;
	}

	/**
	 * Gets the local ID component of the persistent ID.
	 * 
	 * @param resolutionContext
	 *            current resolution context
	 * 
	 * @return local ID component of the persistent ID
	 * 
	 * @throws ResolutionException
	 *             thrown if there is a problem resolving the local id
	 */
	private String getLocalId(AttributeResolutionContext resolutionContext, AttributeResolverWorkContext resolverWorkContext)
			throws ResolutionException {
		log.debug("gets local ID ...");

		StringBuffer localIdValue = new StringBuffer();

		String[] ids = getSourceAttributeId().split(SEPARATOR);
		// get list of already resolved attributes (from dependencies)
		Map <String,ResolvedAttributeDefinition> resolvedAttributesMap = 
				resolverWorkContext.getResolvedIdPAttributeDefinitions();
		
		for (int i = 0; i < ids.length; i++) {

			Collection<IdPAttributeValue<?>> sourceIdValues = null;
			
			if (resolvedAttributesMap.get(ids[i]) != null ) 
				sourceIdValues = resolvedAttributesMap.get(ids[i]).getResolvedAttribute().getValues();
			
			if (sourceIdValues == null || sourceIdValues.isEmpty()) {
				log
						.error(
								"Source attribute {} for connector {} provide no values",
								getSourceAttributeId(), getId());
				throw new ResolutionException("Source attribute "
						+ getSourceAttributeId() + " for connector " + getId()
						+ " provided no values");
			}

			if (sourceIdValues.size() > 1) {
				log
						.warn(
								"Source attribute {} for connector {} has more than one value, only the first value is used",
								getSourceAttributeId(), getId());
			}
			localIdValue.append(sourceIdValues.iterator().next().toString());
		}
		log.debug("local ID: " + localIdValue.toString());

		return localIdValue.toString();
	}

	/**
	 * Creates the targetedID that is unique for a given local/peer/localId
	 * tuple.
	 * 
	 * @param resolutionContext
	 *            current resolution context
	 * @param localId
	 *            principal the the persistent ID represents
	 * @param salt
	 *            salt used when computing a persistent ID via SHA-1 hash
	 * 
	 * @return the created identifier
	 */
	private String createTargetedID(
			AttributeResolutionContext resolutionContext, String localId,
			byte[] salt) throws ResolutionException {

		log.debug("creating targetedID");
		String targetedID = null;

		try {
			String localEntityID = resolutionContext.getAttributeIssuerID();
			String peerEntityID = resolutionContext.getAttributeRecipientID();
			String globalUniqueID = localId + localEntityID + peerEntityID
					+ new String(salt);
			log.info("the uniqueID (user/IdP/SP/salt) : " + localId + " / "
					+ localEntityID + " / " + peerEntityID + " / " + new String(salt));
			byte[] hashValue = DigestUtils.sha1(globalUniqueID);
			byte[] encodedValue = Base64.encodeBase64(hashValue);
			targetedID = new String(encodedValue);
			targetedID = this.replace(targetedID);

		} catch (Exception e) {
			log.error("Failed to create the targetedID", e);
			throw new ResolutionException("Failed to create the targetedID", e);
		}
		return targetedID;
	}

	private String replace(String persistentId) {
		// begin = convert non-alphanum chars in base64 to alphanum
		// (/+=)
		if (persistentId.contains("/") || persistentId.contains("+")
				|| persistentId.contains("=")) {
			String aepst;
			if (persistentId.contains("/")) {
				aepst = persistentId.replaceAll("/", "_");
				persistentId = aepst;
			}

			if (persistentId.contains("+")) {
				aepst = persistentId.replaceAll("\\+", "-");
				persistentId = aepst;
			}

			if (persistentId.contains("=")) {
				aepst = persistentId.replaceAll("=", "");
				persistentId = aepst;
			}
		}

		return persistentId;
	}

	/**
	 * Gets the salt used when computing the ID.
	 * 
	 * @return salt used when computing the ID
	 */
	public byte[] getSalt() {
		return salt;
	}

	public void setSalt(byte[] salt) {
		if (salt.length < MINIMUM_SALT_LENGTH) {
			throw new IllegalArgumentException(
					"Provided salt must be at least "+MINIMUM_SALT_LENGTH+" bytes in size.");
		}
		this.salt = salt;
	}

	/**
	 * Gets the ID of the attribute whose first value is used when generating
	 * the computed ID.
	 * 
	 * @return ID of the attribute whose first value is used when generating the
	 *         computed ID
	 */
	public String getSourceAttributeId() {
		return sourceAttributeId;
	}

	public void setSourceAttributeId(String sourceAttributeId) {
		if (MiscHelper.isEmpty(sourceAttributeId)) {
			throw new IllegalArgumentException(
					"Provided source attribute ID must not be empty");
		}
		this.sourceAttributeId = sourceAttributeId;
	}

	/**
	 * Gets the ID of the attribute generated by this connector.
	 * 
	 * @return ID of the attribute generated by this connector
	 */
	public String getGeneratedAttributeId() {
		return generatedAttributeId;
	}

	public void setGeneratedAttributeId(String generatedAttributeId) {
		if (MiscHelper.isEmpty(generatedAttributeId)) {
			throw new IllegalArgumentException(
					"Provided generated attribute ID must not be empty");
		}
		this.generatedAttributeId = generatedAttributeId;
	}

	/** {@inheritDoc} */
	public void validate() throws ResolutionException {
		if (getDependencies().size() != 1) {
			log.error("targetedID " + getId()
					+ " data connectore requires exactly one dependency");
			throw new ResolutionException("Computed ID " + getId()
					+ " data connectore requires exactly one dependency");
		}
	}
}
