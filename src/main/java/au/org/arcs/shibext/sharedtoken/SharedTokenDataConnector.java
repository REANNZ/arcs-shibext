/**
 * 
 */
package au.org.arcs.shibext.sharedtoken;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Map;

import javax.sql.DataSource;

import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.digest.DigestUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import net.shibboleth.idp.attribute.resolver.AbstractDataConnector;
import net.shibboleth.idp.attribute.resolver.ResolvedAttributeDefinition;
import net.shibboleth.idp.attribute.resolver.context.AttributeResolutionContext;
import net.shibboleth.idp.attribute.resolver.context.AttributeResolverWorkContext;
import net.shibboleth.idp.attribute.resolver.ResolutionException;
import net.shibboleth.idp.attribute.IdPAttribute;
import net.shibboleth.idp.attribute.IdPAttributeValue;
import net.shibboleth.idp.attribute.StringAttributeValue;
import net.shibboleth.idp.attribute.resolver.ResolverPluginDependency;
import net.shibboleth.utilities.java.support.collection.LazyMap;

/**
 * @author Damien Chen
 * 
 */
public class SharedTokenDataConnector extends AbstractDataConnector {

	/** Class logger. */
	private final Logger log = LoggerFactory
			.getLogger(SharedTokenDataConnector.class);

	private static String STORED_ATTRIBUTE_NAME = "auEduPersonSharedToken";

	private static String SEPARATOR = ",";

	/** ID of the attribute generated by this data connector. */
	private String generatedAttribute;

	/**
	 * IdP identifier used when computing the sharedToken.
	 */
	private String idpIdentifier;

	/**
	 * IdP home directory used when getting the IdP's configuration.
	 */
	private String idpHome;

	/**
	 * ID of the attribute whose first value is used when generating the
	 * computed ID.
	 */
	private String sourceAttribute;

	/** Salt used when computing the ID. */
	private byte[] salt;

	/** Whether to store the sharedToken to Ldap */
	private boolean storeLdap;

	/** Whether to search subtree when store the SharedToken */
	private boolean subtreeSearch;

	/** Whether to store the sharedToken to database */
	private boolean storeDatabase;

	/** SharedToken data store. */
	private SharedTokenStore stStore;

	/** Primary key in SharedToken database */
	private String primaryKeyName;

	public SharedTokenDataConnector() {
		super();
		log.info("construct empty SharedTokenDataConnector ...");
	}

	/**
	 * Constructor.
	 * 
	 * @param generatedAttributeId
	 *            ID of the attribute generated by this data connector
	 * @param sourceAttributeId
	 *            ID of the attribute whose first value is used when generating
	 *            the computed ID
	 * @param idSalt
	 *            salt used when computing the ID
	 * @param storeLdap
	 *            Whether to store the sharedToken to Ldap
	 */
	public SharedTokenDataConnector(String generatedAttributeId,
			String sourceAttributeId, byte[] idSalt, boolean storeLdap,
			boolean subtreeSearch, String idpIdentifier, String idpHome,
			boolean storeDatabase, DataSource source, String primaryKeyName) {

		try {
			log.info("construct SharedTokenDataConnector ...");
			if (MiscHelper.isEmpty(generatedAttributeId)) {
				throw new IllegalArgumentException(
						"Provided generated attribute ID must not be empty");
			}
			setGeneratedAttribute(generatedAttributeId);

			if (MiscHelper.isEmpty(sourceAttributeId)) {
				throw new IllegalArgumentException(
						"Provided source attribute ID must not be empty");
			}
			setSourceAttribute(sourceAttributeId);

			if (idSalt.length < 16) {
				log.warn("Provided salt less than 16 bytes in size.");
				// throw new IllegalArgumentException(
				// "Provided salt must be at least 16 bytes in size.");
			}
			setSalt(idSalt);
			setIdpIdentifier(idpIdentifier);
			setIdpHome(idpHome);
			setStoreLdap(storeLdap);
			setSubtreeSearch(subtreeSearch);
			setPrimaryKeyName(primaryKeyName);
			setStoreDatabase(storeDatabase);

			if (storeDatabase) {
				setDataSource(source);
			}

		} catch (Exception e) {
			// catch any exception so that the IdP will not screw up.
                        log.error("Failed to construct SharedTokenDataConnector object", e);
		}

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see
	 * edu.internet2.middleware.shibboleth.common.attribute.resolver.provider
	 * .ResolutionPlugIn
	 * #resolve(edu.internet2.middleware.shibboleth.common.attribute
	 * .resolver.provider.AttributeResolutionContext)
	 */
	/** {@inheritDoc} */

	@Override
	protected Map<String, IdPAttribute> doDataConnectorResolve(
			AttributeResolutionContext resolutionContext, AttributeResolverWorkContext resolverWorkContext)
			throws ResolutionException {

		log.info("starting SharedTokenDataConnector.resolve( ) ...");

		Map<String, IdPAttribute> attributes = new LazyMap<String, IdPAttribute>();

		String sharedToken = null;
		try {
			if (storeDatabase) {
				log
						.info("storeDatabase = true. Try to get SharedToken from database");
				// Collection<Object> colUid =
				// super.getValuesFromAllDependencies(
				// resolutionContext, PRIMARY_KEY);

				// String uid = (String) colUid.iterator().next();

				String uid = resolutionContext.getPrincipal();

				if (stStore != null) {
					sharedToken = stStore.getSharedToken(uid, primaryKeyName);
				} else {
					log.error("SharedTokenStore is null");
					throw new IMASTException("SharedTokenStore is null");
				}
				if (sharedToken == null) {
					log
							.info("sharedToken does not exist, will generate a new one and store in database.");

					sharedToken = getSharedToken(resolutionContext, resolverWorkContext);
					stStore.storeSharedToken(uid, sharedToken, primaryKeyName);
				} else {
					log
							.info("sharedToken exists, will not generate a new one.");
				}
			} else {
				log
						.debug("storeDatabase = false. Try to get SharedToken from LDAP.");
				// TODO-CHECK: get already resolved attribute (from LDAP)
				ResolvedAttributeDefinition resolvedSharedTokenFromLDAP = 
						resolverWorkContext.getResolvedIdPAttributeDefinitions().get(STORED_ATTRIBUTE_NAME);
				IdPAttribute sharedTokenFromLDAP = ( resolvedSharedTokenFromLDAP!=null ? resolvedSharedTokenFromLDAP.getResolvedAttribute() : null);  
				
				if (sharedTokenFromLDAP==null || sharedTokenFromLDAP.getValues().size() < 1) {
					log
							.info("sharedToken does not exist, will generate a new one.");
					sharedToken = getSharedToken(resolutionContext, resolverWorkContext);
					if (getStoreLdap()) {
						log
								.debug("storeLdap=true, will store the SharedToken in LDAP.");
						storeSharedToken(resolutionContext, sharedToken);
					} else
						log
								.info("storeLdap=false, not to store sharedToken in Ldap");
				} else {
					log
							.info("sharedToken  exists, will not to generate a new one.");
					sharedToken = sharedTokenFromLDAP.getValues().get(0).getValue().toString();
				}
			}
			IdPAttribute attribute = new IdPAttribute(getGeneratedAttributeId());
			Collection<IdPAttributeValue<String>> values = new ArrayList<IdPAttributeValue<String>>();
			values.add(new StringAttributeValue(sharedToken));
			attribute.setValues(values);
			attributes.put(attribute.getId(), attribute);
		} catch (Exception e) {
			// catch any exception so that the IdP will not screw up.
			log.error("Failed to resolve " + STORED_ATTRIBUTE_NAME, e);
		}
		return attributes;
	}

	/**
	 * Gets the sharedToken.
	 * 
	 * @param resolutionContext
	 *            current resolution context
	 * 
	 * @return sharedToken
	 * 
	 * @throws ResolutionException
	 *             thrown if there is a problem retrieving or storing the
	 *             persistent ID
	 */
	private String getSharedToken(AttributeResolutionContext resolutionContext, AttributeResolverWorkContext resolverWorkContext)
			throws ResolutionException {

		String localId = getLocalId(resolutionContext, resolverWorkContext);
		String persistentId = this.createSharedToken(resolutionContext,
				localId, salt);
		return persistentId;

	}

	/**
	 * Store the sharedToken.
	 * 
	 * @param resolutionContext
	 *            current resolution context
	 * @param sharedToken
	 * 
	 */

	private void storeSharedToken(
			AttributeResolutionContext resolutionContext, String sharedToken)
			throws IMASTException {

		log.info("calling storeSharedToken() ...");

		try {
			String principalName = resolutionContext.getPrincipal();

			(new LdapUtil()).saveAttribute(STORED_ATTRIBUTE_NAME, sharedToken,
					getDependencies().toArray(new ResolverPluginDependency[0])[0].getDependencyPluginId(), principalName, idpHome, subtreeSearch);
		} catch (Exception e) {
			// catch any exception, the program will go on.
			log.error("Failed to store sharedToken into LDAP", e);
			throw new IMASTException("Failed to save attribute into ldap entry", e);

		}
	}

	/**
	 * Creates the sharedToken that is unique and persistent within a federation
	 * 
	 * @param resolutionContext
	 *            current resolution context
	 * @param localId
	 *            principal the the persistent ID represents, might be a
	 *            combination of attributes, e.g. uid+mail.
	 * @param salt
	 *            salt used when computing a persistent ID via SHA-1 hash
	 * 
	 * @return the created identifier
	 * 
	 * @throws ResolutionException
	 *             thrown if there is a problem
	 */
	private String createSharedToken(
			AttributeResolutionContext resolutionContext, String localId,
			byte[] salt) throws ResolutionException {
		String persistentId;
		log.info("creating a sharedToken ...");
		try {
			String localEntityId = null;
			if (this.idpIdentifier == null) {
				localEntityId = resolutionContext.getAttributeIssuerID();
			} else {
				localEntityId = idpIdentifier;
			}
			String globalUniqueID = localId + localEntityId + new String(salt);
			log.info("the globalUniqueID (user/idp/salt): " + localId + " / "
					+ localEntityId + " / " + new String(salt));
			byte[] hashValue = DigestUtils.sha(globalUniqueID);
			byte[] encodedValue = Base64.encodeBase64(hashValue);
			persistentId = new String(encodedValue);
			persistentId = this.replace(persistentId);
			log.info("the created sharedToken: " + persistentId);
		} catch (Exception e) {
			log.error("Failed to create the sharedToken", e);
			throw new ResolutionException("Failed to create the sharedToken", e);
		}
		return persistentId;

	}

	private String replace(String persistentId) {
		// begin = convert non-alphanum chars in base64 to alphanum
		// (/+=)
		log.info("calling replace() ...");
		if (persistentId.contains("/") || persistentId.contains("+")
				|| persistentId.contains("=")) {
			String aepst;
			if (persistentId.contains("/")) {
				aepst = persistentId.replaceAll("/", "_");
				persistentId = aepst;
			}

			if (persistentId.contains("+")) {
				aepst = persistentId.replaceAll("\\+", "-");
				persistentId = aepst;
			}

			if (persistentId.contains("=")) {
				aepst = persistentId.replaceAll("=", "");
				persistentId = aepst;
			}
		}

		return persistentId;
	}

	/**
	 * Gets the local ID component of the persistent ID.
	 * 
	 * @param resolutionContext
	 *            current resolution context
	 * 
	 * @return local ID component of the persistent ID
	 * 
	 * @throws ResolutionException
	 *             thrown if there is a problem resolving the local id
	 */
	private String getLocalId(AttributeResolutionContext resolutionContext, AttributeResolverWorkContext resolverWorkContext)
			throws ResolutionException {

		log.info("gets local ID ...");

		String[] ids = getSourceAttribute().split(SEPARATOR);
		// get list of already resolved attributes (from dependencies)
		Map <String,ResolvedAttributeDefinition> resolvedAttributesMap = 
				resolverWorkContext.getResolvedIdPAttributeDefinitions();	

		StringBuffer localIdValue = new StringBuffer();
		for (int i = 0; i < ids.length; i++) {
			Collection<IdPAttributeValue<?>> sourceIdValues = null;
			
			if (resolvedAttributesMap.get(ids[i]) != null ) 
				sourceIdValues = resolvedAttributesMap.get(ids[i]).getResolvedAttribute().getValues();

			if (sourceIdValues == null || sourceIdValues.isEmpty()) {
				log
						.error(
								"Source attribute {} for connector {} provide no values",
								getSourceAttribute(), getId());
				throw new ResolutionException("Source attribute "
						+ getSourceAttribute() + " for connector " + getId()
						+ " provided no values");
			}

			if (sourceIdValues.size() > 1) {
				log
						.warn(
								"Source attribute {} for connector {} has more than one value, only the first value is used",
								getSourceAttribute(), getId());
			}
			localIdValue.append(sourceIdValues.iterator().next().getValue().toString());
		}
		log.info("local ID: " + localIdValue.toString());

		return localIdValue.toString();
	}

	/** {@inheritDoc} */
	public void validate() throws ResolutionException {
		if (getDependencies().size() != 1) {
			log.error("SharedToken ID " + getId()
					+ " data connector requires exactly one dependency");
			throw new ResolutionException("SharedToken ID " + getId()
					+ " data connector requires exactly one dependency");
		}
	}

	/**
	 * Gets the salt used when computing the ID.
	 * 
	 * @return salt used when computing the ID
	 */
	public byte[] getSalt() {
		return salt;
	}

	/**
	 * Gets the ID of the attribute whose first value is used when generating
	 * the computed ID.
	 * 
	 * @return ID of the attribute whose first value is used when generating the
	 *         computed ID
	 */
	public String getSourceAttribute() {
		return sourceAttribute;
	}

	public void setSourceAttribute(String sourceAttribute) {
		this.sourceAttribute = sourceAttribute;
	}

	/**
	 * Gets the ID of the attribute generated by this connector.
	 * 
	 * @return ID of the attribute generated by this connector
	 */
	public String getGeneratedAttributeId() {
		return generatedAttribute;
	}

	/**
	 * @return the storeLdap
	 */
	public boolean getStoreLdap() {
		return storeLdap;
	}

	/**
	 * @return the idpIdentifier
	 */
	public String getIdpIdentifier() {
		return idpIdentifier;
	}

	/**
	 * @param idpIdentifier
	 *            the idpIdentifier to set
	 */
	public void setIdpIdentifier(String idpIdentifier) {
		this.idpIdentifier = idpIdentifier;
	}

	public String getGeneratedAttribute() {
		return generatedAttribute;
	}

	public void setGeneratedAttribute(String generatedAttribute) {
		this.generatedAttribute = generatedAttribute;
	}

	public String getIdpHome() {
		return idpHome;
	}

	public void setIdpHome(String idpHome) {
		this.idpHome = idpHome;
	}

	public boolean isSubtreeSearch() {
		return subtreeSearch;
	}

	public void setSubtreeSearch(boolean subtreeSearch) {
		this.subtreeSearch = subtreeSearch;
	}

	public boolean isStoreDatabase() {
		return storeDatabase;
	}

	public void setStoreDatabase(boolean storeDatabase) {
		this.storeDatabase = storeDatabase;
	}

	public String getPrimaryKeyName() {
		return primaryKeyName;
	}

	public void setPrimaryKeyName(String primaryKeyName) {
		this.primaryKeyName = primaryKeyName;
	}

	public void setSalt(byte[] salt) {
		this.salt = salt;
	}

	public void setStoreLdap(boolean storeLdap) {
		this.storeLdap = storeLdap;
	}
	
	public void setDataSource(DataSource source) {
		if (source != null) {
			stStore = new SharedTokenStore(source);
		} else {
			log.error("DataSource should not be null");
			throw new IllegalArgumentException(
					"DataSource should not be null");
		}
	}
}
